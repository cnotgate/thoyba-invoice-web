import { db, client } from '../src/db/client';
import { users, suppliers, invoices } from '../src/db/schema';
import { hashPassword } from '../src/utils/password';
import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';

// Generate a secure random password
function generatePassword(length: number = 16): string {
	const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz23456789!@#$%^&*';
	let password = '';
	const crypto = require('crypto');
	const array = new Uint8Array(length);
	crypto.getRandomValues(array);
	
	for (let i = 0; i < length; i++) {
		password += chars[array[i] % chars.length];
	}
	return password;
}

// Convert legacy date format to ISO format
function convertLegacyDate(legacyDate: string): string | null {
	if (!legacyDate) return null;
	
	// If already ISO format (YYYY-MM-DD), return as-is
	if (/^\d{4}-\d{2}-\d{2}$/.test(legacyDate)) {
		return legacyDate;
	}
	
	// Indonesian month names mapping
	const monthMap: Record<string, string> = {
		'Januari': '01', 'Februari': '02', 'Maret': '03', 'April': '04',
		'Mei': '05', 'Juni': '06', 'Juli': '07', 'Agustus': '08',
		'September': '09', 'Oktober': '10', 'November': '11', 'Desember': '12'
	};
	
	// Try parsing "DD Month YYYY" format (e.g., "17 Januari 2024")
	const match = legacyDate.match(/(\d{1,2})\s+(\w+)\s+(\d{4})/);
	if (match) {
		const day = match[1].padStart(2, '0');
		const month = monthMap[match[2]];
		const year = match[3];
		if (month) {
			return `${year}-${month}-${day}`;
		}
	}
	
	// Try parsing "DD/MM/YYYY" format
	const ddmmyyyy = legacyDate.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
	if (ddmmyyyy) {
		const day = ddmmyyyy[1].padStart(2, '0');
		const month = ddmmyyyy[2].padStart(2, '0');
		const year = ddmmyyyy[3];
		return `${year}-${month}-${day}`;
	}
	
	// Fallback to current date
	return new Date().toISOString().split('T')[0];
}

// Convert legacy timestamp to ISO timestamp
function convertLegacyTimestamp(legacyTimestamp: string): Date {
	if (!legacyTimestamp) return new Date();
	
	// Try parsing "DD/MM/YYYY HH:mm:ss" format
	const match = legacyTimestamp.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})\s+(\d{1,2}):(\d{1,2}):(\d{1,2})/);
	if (match) {
		const day = parseInt(match[1]);
		const month = parseInt(match[2]) - 1; // Month is 0-indexed in JS
		const year = parseInt(match[3]);
		const hour = parseInt(match[4]);
		const minute = parseInt(match[5]);
		const second = parseInt(match[6]);
		return new Date(year, month, day, hour, minute, second);
	}
	
	// Try parsing as ISO string
	const parsed = new Date(legacyTimestamp);
	if (!isNaN(parsed.getTime())) {
		return parsed;
	}
	
	return new Date();
}

// Real supplier names from legacy database
const supplierNames = [
	'Cv Sukses Mandiri',
	'PT. Air Mandiri Distribusindo',
	'PT. Akasia Inter Nusa',
	'PT. Antarmitra Sembada',
	'PT. Anugerah Argon Mandiri',
	'PT. Anugerah Pharmindo Lestari',
	'PT. Bahtera Laju Nusantara',
	'PT. Bangun Citra Lestari',
	'PT. Berkat Sukses Sentosa',
	'PT. Cahaya Makmur Prima Sejahtera',
	'PT. Cahaya Pelita Borneo',
	'PT. Cahaya Putri Bintang',
	'PT. Daya Muda Agung',
	'PT. Dialogue Garmindo Utama',
	'PT. Enseval Putra Mega Trading',
	'PT. IndoMarco Adi Prima',
	'PT. Intiboga Mandiri',
	'PT. Kreasi Perdana Indonesia',
	'PT. Laris Sukses Abadi',
	'PT. Laut Indah Jaya',
	'PT. Laut Timur Ardiprima',
	'PT. Mahkota Lestari',
	'PT. Maju Anugerah Jaya Usaha',
	'PT. Maju Anugerah Jaya Utama',
	'PT. Marga Nusantara Jaya',
	'PT. Mensa Bina Sukses',
	'PT. Mitra Usaha Sukses Sejahtera',
	'PT. Mulia Anugerah Distribusindo',
	'PT. Obor Baru Maju',
	'PT. Oliver Bayi Andalan',
	'PT. Parit Padang Global',
	'PT. Penta Valent',
	'PT. Pulau Baru Jaya',
	'PT. Pundi Mas Sejahtera',
	'PT. Putera Raja Sejahtera',
	'PT. Sejahtera Sukses Sejati Banjarmasin',
	'PT. Selamat Sejahtera Sejati',
	'PT. Semangat Selamat Sejahtera',
	'PT. Sinar Alam Timur',
	'PT. Sumber Sehat Makmur',
	'PT. Surya Timur Raya',
	'PT. Tempo',
	'PT. Tigaraksa Satria',
	'PT. Wildan Cahaya Asri',
	'Winning Mulia',
];

async function seed() {
	console.log('üå± Seeding database...');

	try {
		// Create admin user with auto-generated password (skip if already exists)
		try {
			console.log('Creating admin user...');
			
			// Generate secure random password
			const plainPassword = generatePassword(16);
			const hashedPassword = await hashPassword(plainPassword);
			
			// Create admin user
			await db.insert(users).values({
				username: 'admin',
				password: hashedPassword,
				role: 'admin',
			});
			
			// Save credentials to file
			const credentialsPath = join(process.cwd(), 'ADMIN_CREDENTIALS.txt');
			const credentialsContent = `
===========================================
ADMIN CREDENTIALS - GENERATED BY SEED
===========================================

Username: admin
Password: ${plainPassword}

‚ö†Ô∏è  IMPORTANT SECURITY NOTES:
1. This password was auto-generated during seeding
2. Save this password in a secure location
3. Change this password after first login
4. Delete this file after saving the password
5. Never commit this file to version control

Generated: ${new Date().toISOString()}
===========================================
`;
			
			writeFileSync(credentialsPath, credentialsContent);
			
			console.log('‚úÖ Admin user created!');
			console.log('üìÑ Credentials saved to: ADMIN_CREDENTIALS.txt');
			console.log('‚ö†Ô∏è  IMPORTANT: Save the password from ADMIN_CREDENTIALS.txt and delete the file!');
		} catch (error: any) {
			if (error.code === '23505') {
				console.log('Admin user already exists, skipping...');
			} else {
				throw error;
			}
		}

		// Insert suppliers (skip if already exists)
		console.log(`Inserting ${supplierNames.length} suppliers...`);
		let insertedCount = 0;
		let skippedCount = 0;
		for (const name of supplierNames) {
			try {
				await db.insert(suppliers).values({ name });
				insertedCount++;
			} catch (error: any) {
				if (error.code === '23505') {
					// Supplier already exists, skip
					skippedCount++;
				} else {
					throw error;
				}
			}
		}
		console.log(`‚úÖ Inserted ${insertedCount} suppliers, skipped ${skippedCount} duplicates`);

		// Import legacy invoices (if available)
		console.log('\nüì¶ Checking for legacy invoices...');
		try {
			const legacyDbPath = join(process.cwd(), '..', 'legacy', 'backend', 'db.json');
			
			// Check if legacy file exists
			let legacyData;
			try {
				legacyData = JSON.parse(readFileSync(legacyDbPath, 'utf-8'));
			} catch (fileError: any) {
				if (fileError.code === 'ENOENT') {
					console.log('‚ÑπÔ∏è  Legacy database not found (this is normal in production)');
					console.log('üí° To import legacy data, you can:');
					console.log('   1. Copy legacy db.json to the server');
					console.log('   2. Run the import-legacy-invoices.ts script');
					console.log('   3. Or manually import via admin panel');
					throw fileError; // Exit this try block gracefully
				}
				throw fileError; // Re-throw other errors
			}
			
			if (legacyData.invoices && Array.isArray(legacyData.invoices)) {
				const legacyInvoices = legacyData.invoices;
				console.log(`Found ${legacyInvoices.length} invoices in legacy database`);
				
				let importedCount = 0;
				let errorCount = 0;
				const errorTypes: Record<string, number> = {};
				const sampleErrors: string[] = [];
				
				for (const invoice of legacyInvoices) {
					try {
						await db.insert(invoices).values({
							supplier: invoice.supplier || 'Unknown',
							branch: invoice.branch || 'Kuripan',
							date: convertLegacyDate(invoice.date) || new Date().toISOString().split('T')[0],
							invoiceNumber: invoice.invoiceNumber || `LEGACY-${Date.now()}`,
							total: invoice.total || '0',
							description: invoice.description || null,
							paid: invoice.paid || false,
							paidDate: convertLegacyDate(invoice.paymentDate || invoice.paidDate),
							timestamp: convertLegacyTimestamp(invoice.timestamp),
						});
						importedCount++;
						
						// Show progress every 100 invoices
						if (importedCount % 100 === 0) {
							console.log(`   Imported ${importedCount}/${legacyInvoices.length} invoices...`);
						}
					} catch (error: any) {
						errorCount++;
						
						// Track error types
						const errorKey = error.code || error.message?.substring(0, 50) || 'Unknown';
						errorTypes[errorKey] = (errorTypes[errorKey] || 0) + 1;
						
						// Collect first 5 sample errors with details
						if (sampleErrors.length < 5) {
							sampleErrors.push(
								`Invoice #${invoice.invoiceNumber || 'N/A'} (${invoice.supplier || 'Unknown'}): ${error.message}`
							);
						}
					}
				}
				
				console.log(`‚úÖ Imported ${importedCount} legacy invoices`);
				if (errorCount > 0) {
					console.log(`‚ö†Ô∏è  Skipped ${errorCount} invoices due to errors\n`);
					console.log('Error breakdown:');
					for (const [errorType, count] of Object.entries(errorTypes)) {
						console.log(`   - ${errorType}: ${count} invoices`);
					}
					if (sampleErrors.length > 0) {
						console.log('\nSample errors:');
						sampleErrors.forEach((err, idx) => console.log(`   ${idx + 1}. ${err}`));
					}
				}
			} else {
				console.log('No invoices found in legacy database');
			}
		} catch (error: any) {
			console.log(`‚ö†Ô∏è  Could not import legacy invoices: ${error.message}`);
			console.log('Continuing without legacy data...');
		}

		console.log('\n‚úÖ Seeding completed successfully!');
		console.log('üìÑ Check ADMIN_CREDENTIALS.txt for admin login details');
	} catch (error) {
		console.error('‚ùå Seeding failed:', error);
		process.exit(1);
	} finally {
		await client.end();
	}
}

seed();
